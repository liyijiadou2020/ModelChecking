





# 1 命题逻辑

1.1 判断语句

![image-20241217123718864](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217123718864.png)

**4个基本的逻辑连接词：¬ ∨ ∧ ->**

约定：

优先级：

1. ¬ 大于 ∨ ∧ 大于 ->
2. 蕴含 -> 是右结合的。

逻辑等价（6个逻辑等价式）【存疑?】

![image-20241217124528480](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217124528480.png)



1.2 自然演绎

1.2.1 自然演绎规则

- 合取规则：合取引入、合取消去
- 双重否定规则
- 蕴含消去规则：【最著名的分离规则】、
- 蕴含引入规则
- 析取规则
- 否定规则



1.2.2 派生规则

- 反证规则（PBC）：推出矛盾，说明前提不成立
- 排中律（LEM）：如果 φ∨¬φ 是真的，那么无论 φ 是什么，它一定是真的。



1.2.3 自然演绎总结：

![image-20241217125905215](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217125905215.png)

![image-20241217125925112](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217125925112.png)



1.2.4 逻辑等价

定义：

>  逻辑命题之间的逻辑等价

![image-20241217130510460](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217130510460-17344299116271.png)



1.3 形式化定义命题逻辑

*被严格定义的字符串公式，这样的公式成为合式公式（well-formed）。*

![image-20241217130942482](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217130942482.png)

根据BNF（一种定义语法的范式，可以理解成一种规定），可以把命题逻辑的定义更加紧凑地写为：

![image-20241217131042234](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217131042234.png)

`::=` 的右边表示一个合式公式。

定义就是用来规定哪些公式属于命题逻辑，哪些不是的。那么怎样判断一个公式是否是合式呢？方法是对公式画一棵语法分析树。



语法分析树【重要！】

如何构造一棵合式公式的语法分析树？

举例：一个公式 φ：![image-20241217131255435](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217131255435.png)

它的语法分析树为：

![image-20241217131303377](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217131303377.png)

- 如果树的所有叶子都是原子命题，且所有分支结点都是逻辑连接词，那么它对应的公式就是一个合式公式。

  

---



# 2 谓词逻辑

谓词逻辑也被称为一阶逻辑。它比命题逻辑更精确。

命题逻辑：处理“否”、“并”、“或”、“如果”

谓词逻辑：处理“存在...”，“所有...”，“在..中”，“只有...”



在谓词逻辑中，我们要先明白 谓词、变量、量词 这些词的含义是什么。

我们来看一个判断语句：“每个学生都比他的某个老师年轻”

- 谓词：S(andy)中的S是一个谓词，S(andy)表示Andy是一个学生
- 变量：变量是一个实际值的占位符。S(x)中，x是一个变量。
- 量词：引入两个量词 ∀（读作：对所有的）和 ∃（读作：存在某个），它们总是紧跟变量出现，比如 ∀x（对所有x）或 ∃z（存在z）

现在我们用完全符号的形式来写上述语句：

![image-20241217133710566](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217133710566.png)

事实上，这种代码是对原句的一种表述。上面形式化语言重新翻译过来即：

*对任意x，若x是一个学生，则存在某个y，y是一位老师，使得x比y年轻。*



另一个例子：*不是所有的鸟都可以飞。*



2.2 作为形式语言的谓词逻辑

- 项
- 公式

我们的任务是构建谓词逻辑公式的语法规则。

注意，谓词逻辑公式中涉及两种对象：

1. x、v 这样的变量
2. m(a), g(x, y) 这样的对象

在谓词逻辑中，用来表示对象的表达式称为**项**（term）。

Y(x, m(x)) 是**公式**。



---

2.2.1 项：

![image-20241217154106239](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217154106239.png)

2.2.2 公式：![image-20241217154126005](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217154126005.png)

优先级：

- ¬、∀y、∃y 绑定优先级最高
- 其次是∨ ∧ 
- 最后是->，它是右结合的。

谓词逻辑的语法分析树：

![image-20241217154257805](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217154257805.png)

2.2.3 自由/约束变量



2.2.4 代换

![image-20241217154636326](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217154636326.png)



2.3 谓词逻辑的证明

- 相等的证明规则

- 全称量词的证明规则

  

量词的等价

![image-20241217155244124](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217155244124.png)

![image-20241217155259410](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217155259410.png)



2.7 软件的围观模型

到目前为止，我们的两个中心问题是：

- 模型检测(model checking)：给定谓词逻辑的一个公式φ和一个相匹配的模型M，确定 M|=φ 是否成立
- 语义推导(semantic entailment)：给定谓词逻辑的一个公式集Г，确定 Г|=φ 是否有效



---

# 3 通过模型检测进行验证

3.1 验证的冬季

这一章的重要问题是：**逻辑怎样用来验证程序或系统的正确性。**

形式化验证技术有3部分：

- 描述语言：用于系统建模
- 规范语言：用于描述待验证的形式
- 验证方法：用来确定系统描述是否满足规范、

基于证明进行的验证：系统描述是一组公式Г，而规范是另一个公式φ。验证的方法就是试图找到 Г|-φ 的证明。

基于模型进行验证：系统由逻辑模型M表示。而规范是另一个公式φ。验证方法是由计算模型M是否满足φ构成（写作 M|=φ ）。

我们在本章关注一种叫做模型检测(model checking)的验证方法。根据分类，模型检测是一种自动的、基于模型的、性质验证处理方法。这种方法预期用于并发的、反应式系统。

模型检测基于时态逻辑。时态逻辑的思想是，在一个模型中公式的真与假不是静态的。时态逻辑的模型包含若干状态，一个公式在某些状态下为真，在其他状态下为假。公式可以随系统的状态演化而改变其真值。

在模型检测中，模型M是一个迁移系统（transition systems），而性质φ是时态逻辑公式。为了验证一个系统满足一个性质，我们必须做3件事：

- 用Promela语言对系统进行建模，得到模型M
- 用Promela语言对性质进行编码，产生一个时态逻辑公式φ
- 以M和φ作为输入，运行模型检测器。

这里的Promela语言可以换成满足条件的其他。



- 线性时间逻辑（LTL）把时间看成路径的集合，这里的路径是时间的一个序列。
- 分支时间逻辑（CTL）把时间表示为树，以当前时间为根向未来分叉。



本章我们研究一种时间是线性的逻辑，称为**线性时间逻辑**（Linear-time Temporal Logic，LTL）以及另一种时间是分支的逻辑，即**计算树逻辑**（Computation Tree Logic，CTL）。

模型检测就是对问题 `M,s|=φ` 是否成立计算答案的过程。

这里φ是LTL或CTL中的一个公式，M是系统的一个模型，s是系统的一个状态，|=是满足关系。



## 3.2 线性时间逻辑（LTL）

我们固定一个原子公式集合Atoms（原子公式 p, q, r, ...），它们代表了系统可能成立的原子事实。

3.2.1 LTL的语法（p131）

![image-20241217163205295](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217163205295.png)

连接词 X, F, G, U, R 和 W 称为时态连接词（temporal connectives）

X - 下一个状态

F - 某个未来状态

G - 所有未来状态

U - 直到

R - 释放

W - 弱一直到

这里是LTL公式的一些例子：

![image-20241217164523664](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217164523664.png)

![image-20241217164532547](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217164532547.png)

约定3.2 优先级：

- 一元连接词（包括 ¬ 和时态连接词 X, F, G）具有最高绑定级
- 接下来是 U, R, W
- 然后是 ∨ ∧ 
- 最后是 ->，它是右结合的。

![image-20241217165035532](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217165035532.png)



3.2.2 LTL语义

定义3.4 迁移系统M

![image-20241217180159579](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217180159579.png)

例子：

![image-20241217180243875](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217180243875.png)

定义3.5 路径

![image-20241217180341241](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217180341241.png)

定义3.6 满足关系|=（路径满足一个LTL公式）【重要！】

![image-20241217180427420](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217180427420.png)

![image-20241217180821989](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217180821989.png)

对于U的定义，一定要特别留意！

![image-20241217181035873](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217181035873.png)

W和R暂时不讨论了。

注意！在语句9~13中，未来包括了当前。这意味着，当我们在说“所有未来状态”时，我们将当前状态作为一种未来状态包括了进来。这样做是一种约定。

定义3.8 `M,s|=φ`            -------->【重要！】

![image-20241217181311559](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217181311559.png)

例子：

我们对图3-3的迁移系统做MC：

![image-20241217181614549](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217181614549.png)

把系统M展开成一棵语法树，如下图所示：

![image-20241217181659949](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217181659949.png)

![image-20241217181749552](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217181749552.png)

![image-20241217181754510](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217181754510.png)



3.2.4 LTL公式之间的重要等价

定义3.9 LTL公式之间的等价      -----------> 也许重要，有题型

![image-20241217182136643](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217182136643.png)

等价意味着他们之间可以互换。

在命题逻辑中，∨ ∧是互相对偶的。

![image-20241217182324261](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217182324261.png)

在LTL中，F和G 是互相对偶的，X与其自身对偶：

![image-20241217182248861](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217182248861.png)

![image-20241217182411707](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217182411707.png)

![image-20241217182632662](笔记-《面向计算机科学的数理逻辑系统建模》.assets/image-20241217182632662.png)



## 3.4 分支时间逻辑（CTL）

在前面各节中对LTL（线性时态逻辑）的分析中，我们注意到LTL公式是在路径上赋值的。**我们定义系统的一个状态满足一个LTL公式，如果由给定状态出发的所有路径都满足它。** 于是，LTL隐含着对所有路径做全称量词限定。因此，断言一条路径存在的性质不能用LTL表达。通过考虑问题中性质的否定并相应地解释结果，可以部分缓解这个问题。











