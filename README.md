# 梳理PPT

Лекция 1: [[Модуль 1. Введение]] **Введение**

Лекция 2: [[Модуль 2. Дедуктивная верификация]] **Дедуктивная верификация. Метод Флойда-Хоара доказательства  корректности программ**

Лекция 3: [[Модуль 2. Дедуктивная верификация_2]] **Метод Флойда-Хоара доказательства  корректности программ (2)**

Лекция 4: [[Модуль 3. Темпоральные логики]] **Темпоральные логики**

Лекция 5: [[Модуль 4. MC для LTL_1]] **Алгоритм Model checking для проверки выполнимости формул CTL**

Лекция 6: [[Модуль 4. MC для LTL_2]] **Model checking для формул LTL**

Лекция -: [[Модуль 5. Автоматические средства верификации. LTL]] **Spin**

Лекция 7: [[Модуль 7. Алгоритм MC для проверки выполнимости формул CTL]] **Алгоритм Model checking для проверки  выполнимости формул CTL**

Лекция 8: [[Модуль 8. Алгоритм MC для проверки выполнимости формул CTL_2]] **Model checking для формул LTL  часть 2**

Лекция 10: [[Модуль 9. Символьная верификация CTL]]  **Символьная проверка моделей**

Лекция 11: [[Модуль 9. Символьная верификация CTL——2]]  **Символьная верификация: BDD** 

Лекция 9: [[Модуль 10. Применение темпоральных логик для выражения свойств]] **Спецификация свойств ПАРАЛЛЕЛЬНЫХ программ**

Лекция 12: [[Модуль 11. Вероятностная и количественная верификация]] **Количественный анализ дискретных систем**

Лекция 14: [[Модуль 12. Верификация систем реального времени]] **Верификация систем реального времени**

==Темы, которые будут на экзамене:==

**Темы, которые будут на экзамене:**

\1. Введение. Проблема верификации

\2. Программная логика Флойда-Хоара

\4. Темпоральные логики

\5. Алгоритмы верификации для логики CTL

\6. Алгоритмы верификации для логики LTL

\8. Структуры Крипке как модели параллельных программ

\9. Спецификация свойств параллельных программ

\11. Бинарные решающие диаграммы (BDD)

\12. Символьная верификация. Неподвижные точки операторов

\13. Вероятностная логика ветвящегося времени

\14. Верификация систем реального времени

![image-20241219185548459](README.assets/image-20241219185548459.png)

# ChatGPT 聊天记录

人：我一共发送了16个文件，请你在完成阅读后全面、详细地讲述每个PPT都阐述了哪些内容？请按照这样的格式给出： PPT标题 主要内容大纲 各章节要解决的问题、具体内容

GPT：

请稍等，我将逐一分析并汇总所有16个文件的内容并按照您指定的格式详细说明。

以下是对您提供的16个PPT的全面解读，按照格式分类整理如下：

### PPT 1: Введение +

**主要内容大纲**

- 分布式系统验证的重要性。
- 验证的基本方法。
- Kripke 结构和形式化模型简介。

各章节要解决的问题、具体内容：

1. 什么是分布式系统验证？
   - 定义与目标：确保系统满足设计规范。
   - 强调形式化验证的重要性，避免高昂的错误代价。
2. 形式化方法简介：
   - Hoare 三元组方法。
   - 模型检测 (Model Checking) 的应用范围。
3. Kripke 结构：
   - 描述系统的状态和转换关系。
   - 用作形式化逻辑的基础模型。

### PPT 2: Дедуктивная верификация +

**主要内容大纲**

- Hoare 逻辑和程序正确性证明。
- 弱化和强化条件的使用。
- Floyd 方法的推理逻辑。

各章节要解决的问题、具体内容：

1. 如何使用三元组验证程序？
   - 介绍 `{P} S {Q}` 的语法和语义。
   - 演示如何用三元组表达程序的输入、操作和输出之间的关系。
2. 如何证明程序的部分正确性？
   - 通过求解最弱前置条件 (Weakest Precondition)。
   - 示例说明预条件和后条件的推导过程。
3. 方法扩展：
   - 推导强后置条件 (Strongest Postcondition) 以验证复杂程序的正确性。

### PPT 3: Темпоральные логики +

**主要内容大纲**

- 时序逻辑的分类和应用。
- CTL、LTL 公式的语法和语义。
- CTL* 的综合表达能力。

各章节要解决的问题、具体内容：

1. 如何用时序逻辑表达系统行为？

   - LTL 公式适合线性时间系统。
   - CTL 表达树形结构中状态间的关系。

2. 如何结合实际需求选择逻辑？

   - 示例：控制系统的安全性与活性分析。
   - 通过实际案例对比 LTL 和 CTL 的适用性。

3. *CTL* 的扩展能力：

   *

   - 结合 LTL 和 CTL 的优点，提升表达复杂性的能力。

### **PPT 4: MC для LTL**

**主要内容大纲**

- 针对 LTL 公式的模型检测方法。
- Kripke 结构与 Büchi 自动机的结合。
- LTL 验证算法的实现。

各章节要解决的问题、具体内容：

1. 如何验证 LTL 公式？
   - 将 LTL 公式转换为 Büchi 自动机。
   - 利用 Kripke 结构描述系统状态。
2. 如何优化模型检测的效率？
   - 使用状态简化和路径搜索策略。
   - 分析复杂系统的路径选择问题。

### **PPT 5: Автоматические средства верификации (LTL)**

**主要内容大纲**

- 自动工具验证的工作流程。
- SPIN 工具及其使用示例。
- Promela 语言的基础语法。

各章节要解决的问题、具体内容：

1. 如何利用 SPIN 进行验证？
   - 编写 Promela 模型描述系统行为。
   - 配置 SPIN 工具检测 LTL 公式。
2. 实际应用：
   - 验证通信协议和分布式算法的正确性。
3. 结果解释：
   - 读取验证输出，定位潜在错误。

### **PPT 6: Построение альтернирующего автомата**

**主要内容大纲**

- 构建交替自动机以优化验证。
- 自动机与时序逻辑的联系。
- 交替自动机的状态转换规则。

各章节要解决的问题、具体内容：

1. 什么是交替自动机？
   - 定义：多路径状态转换的自动机。
   - 与 Büchi 自动机的对比。
2. 如何利用交替自动机验证复杂公式？
   - 转换 LTL 公式以减少状态数。
   - 优化验证算法的计算复杂性。

### **PPT 7: Построение автомата Бюхи**

**主要内容大纲**

- Büchi 自动机的构造方法。
- 在验证中的具体应用。
- 转换和合并状态的规则。

各章节要解决的问题、具体内容：

1. 如何从公式构建 Büchi 自动机？
   - 分步骤示范公式到自动机的转换。
2. 如何通过自动机进行模型检测？
   - 结合 Kripke 结构，验证系统行为的正确性。

### **PPT 8: Алгоритм МС для CTL**

**主要内容大纲**

- CTL 的模型检测方法。
- 基于 Kripke 结构的标记算法。
- 常见的 CTL 属性验证。

各章节要解决的问题、具体内容：

1. 如何验证 CTL 公式？
   - 使用递归标记算法检查每个状态。
2. 如何应对状态爆炸问题？
   - 通过状态压缩和分区减少计算复杂度。

### **PPT 9: Символьная верификация CTL**

**主要内容大纲**

- BDD 的基本概念。
- 符号模型检测的方法。
- 克服状态爆炸问题的策略。

各章节要解决的问题、具体内容：

1. 什么是符号验证？
   - 利用布尔函数和 BDD 表示状态集合。
2. 如何提高验证规模？
   - BDD 在大型系统中的高效存储和操作。

### **PPT 10: Применение темпоральных логик**

**主要内容大纲**

- 时序逻辑在工业中的应用。
- 编写逻辑公式的常见错误和改进方法。

各章节要解决的问题、具体内容：

1. 如何表达因果关系？
   - 示例说明如何用 LTL 表达实时系统行为。
2. 复杂逻辑公式的优化：
   - 减少冗余逻辑，提升公式可读性。

### **PPT 11: Вероятностная и количественная верификация**

**主要内容大纲**

- PCTL 的定义与应用。
- 概率 Kripke 结构的扩展。
- 定量化验证的案例。

各章节要解决的问题、具体内容：

1. 如何对系统行为进行量化？
   - 用 PCTL 表达概率约束和时序属性。
2. 如何结合概率分析和模型检测？
   - 使用马尔可夫链计算路径概率。

### PPT 12: Верификация систем реального времени +

**主要内容大纲**

- 实时系统的时间属性验证。
- 时钟自动机的引入及应用。

各章节要解决的问题、具体内容：

1. 如何定义实时系统？
   - 建立时间限制和系统状态的关联。
2. 如何验证实时系统行为？
   - 利用 UPPAAL 等工具进行模型检测。

### PPT 13: Структура Крипке

**主要内容大纲**

- Kripke 结构的理论与应用。
- 建模系统状态和转换的基础。

各章节要解决的问题、具体内容：

1. 如何构建 Kripke 结构？
   - 从系统需求提取状态和转换关系。
2. 如何用 Kripke 结构验证公式？
   - 通过路径搜索实现公式验证。

### PPT 14: BDD и их применение +

**主要内容大纲**

- BDD 的构造与优化。
- 在 Model Checking 中的具体应用。

各章节要解决的问题、具体内容：

1. 什么是 BDD？
   - 定义和基本构造方法。
2. 如何用 BDD 优化存储？
   - 减少布尔表达的冗余。

### PPT 15: Примеры верификации

**主要内容大纲**

- 具体验证工具的案例分析。
- Spin 和 Promela 的实际应用。

各章节要解决的问题、具体内容：

1. 如何选择验证工具？
   - 根据系统需求选择合适的验证方法。
2. 案例分析：
   - 多个系统验证的成功经验分享。

### PPT 16: Количественный анализ

**主要内容大纲**

- 系统性能的定量化分析。
- 延迟、可靠性等指标的计算方法。

各章节要解决的问题、具体内容：

1. 如何结合模型检测和性能分析？
   - 使用统计方法评价系统设计的鲁棒性。

以上是对所有PPT内容的详细分类和分析。这些课件系统地介绍了分布式系统验证的理论和实际应用方法，为学习者提供了全面的知识框架。



---

人：请仔细阅读这门课程的考试题目。请说说，考试题目涵盖了哪些内容？可以在哪个PPT的哪个部分中找到对应的解题方法？

GPT：

通过分析考试题目，可以总结出以下涵盖的内容及其对应的PPT章节，提供解题参考：

### **考试题目涵盖的内容及解题对应章节**

#### **1. Kripke 结构与 CTL 公式验证**

**题目示例：**

- 在 Kripke 结构中检查 CTL 公式的满足性，例如 `A[p U E(q U r)]`。

**涉及内容：**

- 定义 Kripke 结构及其状态转换。
- CTL 公式的语义及验证方法。

**解题对应章节：**

- **PPT 1 (Введение)**：Kripke 结构基础。
- **PPT 8 (Алгоритм МС для CTL)**：CTL 公式验证的算法。

#### **2. LTL 公式表达与验证**

**题目示例：**

- 将特定系统属性用 LTL 公式表达，例如：
  - `每个警报事件前必须有故障事件`。
- 验证两条 LTL 公式是否等价。

**涉及内容：**

- LTL 公式的语法和语义。
- 使用 Büchi 自动机进行公式验证。

**解题对应章节：**

- **PPT 3 (Темпоральные логики)**：LTL 公式的基本语法。
- **PPT 4 (MC для LTL)**：LTL 验证方法。
- **PPT 7 (Построение автомата Бюхи)**：Büchi 自动机构造及验证。

#### 3. 时序逻辑与因果关系

**题目示例：**

- 验证逻辑公式的正确性，例如：
  - `FG(p->q)`。
- 判断 CTL 和 LTL 公式的语义差异。

**涉及内容：**

- 时序逻辑操作符的形式化定义。
- CTL 和 LTL 的比较。

**解题对应章节：**

- **PPT 3 (Темпоральные логики)**：时序逻辑的基础。
- **PPT 10 (Применение темпоральных логик)**：时序逻辑在因果关系表达中的应用。

#### 4. 符号模型检测与状态爆炸问题

**题目示例：**

- 构建 BDD 以优化状态存储，例如 `f = a AND (b OR c)`。
- 确定符号验证的效率。

**涉及内容：**

- 符号验证方法及其在大型系统中的应用。
- 使用 BDD 表示布尔函数。

**解题对应章节：**

- **PPT 9 (Символьная верификация CTL)**：符号验证方法。
- **PPT 14 (BDD и их применение)**：BDD 的构造与优化。

#### 5. 实时系统与时钟自动机

**题目示例：**

- 验证时间约束系统属性，例如 `E[x ≤ y U @s2(x > y)]`。
- 分析系统是否满足特定实时逻辑公式。

**涉及内容：**

- 时钟自动机的定义和建模。
- 实时系统的验证方法。

**解题对应章节：**

- **PPT 12 (Верификация систем реального времени)**：实时系统和时钟自动机的验证。

#### **6. 概率逻辑与 PCTL**

**题目示例：**

- 验证 PCTL 公式，例如 `P>0.5[X(a U b)]`。
- 分析概率 Kripke 结构中公式的满足性。

**涉及内容：**

- PCTL 的定义及语法。
- 使用概率 Markov 模型进行分析。

**解题对应章节：**

- **PPT 11 (Вероятностная и количественная верификация)**：概率 Kripke 结构和 PCTL 验证。

#### 7. Hoare 逻辑与程序正确性

**题目示例：**

- 使用 Hoare 逻辑验证程序正确性，例如计算阶乘程序的正确性。

**涉及内容：**

- Hoare 三元组方法。
- 循环不变式和弱前置条件的推导。

**解题对应章节：**

- **PPT 2 (Дедуктивная верификация)**：Hoare 逻辑和程序正确性。

#### 8. Promela 与 SPIN 的应用

**题目示例：**

- 使用 Promela 语言为系统建模，并用 SPIN 工具验证属性。

**涉及内容：**

- 使用 Promela 描述系统行为。
- 利用 SPIN 工具验证分布式系统属性。

**解题对应章节：**

- **PPT 5 (Автоматические средства верификации)**：Promela 语言和 SPIN 工具应用。



### **总结**

考试题目全面涵盖了课程的核心知识点，包括时序逻辑、模型检测、符号验证、概率逻辑以及实时系统的验证。每个题目都可以通过上述 PPT 提供的内容和方法进行解决，为学生理解和应用分布式系统验证工具提供了完整的指导。

---

# 笔记

1.Введение

2.Метод Флойда-Хоара доказательства корректности программ 

3.Исчисление взаимодействующих систем (CCS) Р.Милнера 

4.Темпоральные логики 

5.Алгоритм Model checking для проверки выполнимости формул CTL

6.**Автоматный подход к проверке выполнимости формул** **LTL** 

7.**Система верификации** **Spin** **и язык** **Promela****. Примеры верификации**

8.Структура Крипке как модель реагирующих систем  

9.Темпоральные свойства систем   

10.Применения метода верификации model checking  

11.BDD и их применение   

12.Символьная проверка моделей  

13.Количественный анализ дискретных систем при их верификации  

14.Верификация систем реального времени    

15.Консультации по курсовой работе 



## Дедуктивная верификация -  Метод Флойда-Хоара

Дедуктивная верификация. Метод Флойда-Хоара доказательства корректности программ

演绎验证。证明程序正确性的 Floyd-Hoare 方法

> Дедуктивные методы верификации 演绎验证方法

### 定义

根据 **PPT 2: Дедуктивная верификация** 的 **第4页**：

**Дедуктивная верификация – это метод доказательства правильности программ, основанный на логическом выводе, где корректность программы выражается в виде логических утверждений (триплетов Хоара) и доказывается с использованием правил вывода.**

翻译如下：

**演绎验证方法是一种基于逻辑推理的程序正确性证明方法，通过将程序的正确性形式化为逻辑断言（如 Hoare 三元组）并使用推理规则加以证明。**

演绎验证的核心是使用逻辑方法为程序的所有可能执行路径提供数学证明。



##### 1. 方法论（第6页）：

演绎验证方法依赖以下三大核心：

- **Hoare 逻辑：** 提供一组推导规则来验证程序的部分正确性和全局正确性。
- **弱化/强化条件：** 在验证循环和分支语句时，通过推导更弱的前置条件或更强的后置条件逐步推进证明过程。
- **循环不变式：** 在验证循环程序时，定义一个在循环执行过程中保持为真的谓词，用于证明循环体的正确性。

##### 2. Hoare 三元组的验证（第7页）：

PPT 中给出了以下 Hoare 三元组的验证步骤：

1. 定义前置条件 P：
   - 描述程序开始执行前的状态。
2. 推导循环不变式：
   - 保证循环每次迭代后程序状态符合不变式。
3. 证明后置条件 Q：
   - 验证程序终止后，状态满足目标要求。

示例：

```
{N > 0}  
f := 1;  
x := N;  
while x > 0 do  
  f := f * x;  
  x := x - 1;  
end  
{f = N!}
```

**前置条件 P: N > 0：** 输入的 N 是一个正整数。

**循环不变式 I: f = (N - x)!：** 每次迭代中保持为真。

**后置条件 Q: f = N!：** 程序终止时，f 存储 N 的阶乘。



##### 3. 方法优缺点（第9页）：

- **优点：**
  - 提供程序正确性的数学证明，确保严谨性。
  - 可用于安全关键系统的验证（如航空航天、医疗设备软件）。
- **缺点：**
  - 对于复杂系统，手动验证成本高，可能需要辅助工具。
  - 对程序员的逻辑和数学能力要求较高。



> 什么是“正确的程序”？

「正确的程序」是指一个程序在任何给定输入情况下，都能够按照预期的逻辑正确地执行，并满足给定的功能需求和行为规范。正确性通常包括两方面：

1. **部分正确性 (Partial Correctness)：** 程序在终止时，输出结果满足后条件。
2. **全局正确性 (Total Correctness)：** 除了部分正确性，还要求程序能够在有限时间内终止。



PPT中的定义

在 **PPT 2: Дедуктивная верификация** 的 **第8页** 提到：

*Программа считается правильной, если для всех допустимых входных данных её выполнение завершается корректным результатом, соответствующим спецификации.*

翻译如下：

*如果程序在所有允许的输入下，其执行都能返回与规格一致的正确结果，则认为该程序是正确的。*



> 「正确的程序」的数学表达

根据 Hoare 逻辑，用三元组 `{P} S {Q}` 表示程序的正确性：

- P：程序的前置条件。
- S：程序语句。
- Q：程序的后置条件。

如果程序 S 在满足 P 的情况下执行，结果能够满足 Q，则程序被认为是部分正确的。如果进一步证明 S 一定能终止，则是完全正确。



> 「正确的程序」的数学表达，示例









> 谓词（предикат）

- 值域只有T、F两个取值的函数称为谓词。例如 a>b 就是一个谓词。

- 谓词可以描述一个集合的子集。比如谓词 x>y 描述了 {<x, y>} 这个集合内所有满足 x>y 的数对。比如 <5,3>、 <10,6> ... 等等。



> 状态、程序、变换性的、需求(требование)

- 状态就是变量值组成的向量组
- 程序就是在状态集合的转换器
- 这样的程序称之为变换性的
- 需求规定了程序的初始状态和最终状态应该是什么样的



> Спецификация (описание) требований к программе 程序需求的规范化描述

规格说明是对程序需求的形式化描述：包括程序的初始条件和期望的运行结果，用于明确程序在正确运行时必须满足的功能要求。

规格说明的组成部分：

1. **前置条件 I（предусловие，Pre-condition）：**
   - 谓词，该谓词给出了我们能保证程序正确工作的所有值
   - 比如，对于程序“提取平方数”来说，前置条件就是 x>=0
2. **后置条件 R（постусловие，Post-condition）：**
   - 谓词，该谓词定义了正确的结果，也就是程序运行后我们的期望结果。



需求与具体算法无关。

比如：

求最大公约数的需求可以表示为：

I := { (m, n ∈ N)};

R := { H = 最大公约数(m, n) }



*Для программы Р, вычисляющей НОД, сформулируем  УТВЕРЖДЕНИЕ: “Если m и n – любые натуральные числа до выполнения программы Р,  то послезавершения Р переменная Н будет равна НОД(m,n)”.*



部分正确性、完全正确性

> 部分正确性

Частичная (partial) корректность программы: { I } P { R }:

“Если состояния программы  P удовлетворяют предусловию I до начала работы программы, 

И программа  после  P завершится,  

ТО после завершения P состояния программы будут удовлетворять постусловию R”.

翻译：”如果程序P在开始前满足前置条件I，且程序P能够结束的条件下，那么结束程序P的时候状态将会满足后置条件R “



> 完全正确性

Полная (тотальная, total) корректность программы: [ I ] P [ R ]:

"Если предусловие I истинно до начала работы программы S,

ТО Pзавершится,

И после завершения программы P будет истинно постусловие  R"

翻译：“如果前置条件I在运行程序前为真，那么P一定能结束，且结束时必有后置条件R为真。”



> 部分正确性和完全正确性的关系

Total correctness = Partial correctness +   Termination



> 霍尔三元组（Hoare Triple）

假设存在一个程序P，前置条件I，后置条件R(assertions)，那么 { I } P { R } 就是一个霍尔三元组。

{ I } P { R } 这个三元组读作：只要I在P执行之前成立，则执行之后R也成立。注意如果程序P不终止，那就没有”之后“了，所以Q在**此时**可以是任何语句，甚至可以为假。

*Утверждение {I} Р {R}: Программа Р частично корректна относительно предусловия  I  и постусловия  R*

翻译：*霍尔断言 {I} Р {R}：程序P相对于前条件I和后条件R部分正确。*

怎样证明断言的真实性(永远为真)？

换言之，怎样证明，对于任意满足谓词I的初始值，在执行程序P之后的状态都能保证满足谓词R？



> 谓词之间的关系

谓词之间的关系包括：等价关系、包含关系、互斥关系

谓词之间的运算包括：合取、析取

- 等价关系：
  - 定义：如果在所有可能的程序状态下 P1 和 P2 的真假值总是相同，则谓词 P1 和 P2 等价。
  - 表示：P1 ⇔ P2。

- 包含关系 / 强弱关系：

  - 定义：如果 P1 为真，P2 一定为真
  - 表示：P1  ⟹  P2 表示 P1 的真包含 P2 的真。
  - 也可以表述为 “P1比P2更强”
  - 小技巧：小范围推大范围，所以P1是小范围，P2是大范围！谁在前面谁更强！

  - 一些特例：
    - False 是最强的条件（最强谓词）
    - True 是最弱的条件（最弱谓词）
    - 记忆：至贱则无敌，真理是柔弱的。


### sp (最强后置条件)

> 最强后置条件 strongest postcondition (sp) сильнейшее постусловие

弗洛伊德认为，程序是谓词的变换器。

▶ 以下我的理解，有点长：

之所以说程序是谓词变换器，是因为程序在运行之前满足一个谓词I，运行之后满足另一个谓词R。对于系统状态集合来说，程序使满足的谓词从I变成了R。（应该不是很充分，后续再研究下）

假设系统的初始状态分布在一个抛物线 `y = x^2 - 6x + 2` 上，经过程序 { x += 1; y -=2 } 之后，系统的最终状态分布到了另一个抛物线 `y = x^2 - 8x + 7` 上。也就是说，系统满足的谓词从 `y = x^2 - 6x + 2` 变成了 `y = x^2 - 8x + 7`。这种变化是由程序造成的。

那么我们知道了这个可以做什么？

我们现在知道了，程序可以让谓词A变换成谓词B，如果我们把谓词替换成“条件”（这样的替换是合理的，因为程序的输入输出通常就是谓词，比如输入条件: x, y都是自然数，输出条件： x=y + 3），那么这句话也可以等价为：程序可以让状态从满足条件A变为满足条件B。

结合最强后置定理：如果程序的最强后置条件 sp 可以推导出最终满足的状态 R，那么，这个程序必然满足部分正确性。

我们可以找到一个判断程序是否正确的方法！

同样用上面的抛物线举例。假设我现在有 前置状态 `y = x^2 - 6x + 2`，后置状态 `y = x^2 - 8x + 7` ，和程序 `{ x += 1; y -=2 }`。我想要知道这个程序能否满足我的需求？即经过程序的运行之后，所有满足前置状态的点都能分布到后置状态规定的集合里去。

一开始可能无从下手，因为我不可能对无限多的测试数据做验证。但是最强后置定理却给了我们一个从数学上证明程序正确性的方法。

根据最强后置定理，我只需要判断：程序的最强后置条件 sp 是否可以推导出最终状态  `y = x^2 - 8x + 7` 即可（即，sp谓词比最终状态谓词“强”，形式化表示：`sp => y = x^2 - 8x + 7`）

所以要做的事情非常清晰了，步骤如下：

1. 求出 `sp`
2. 判断 `sp => y = x^2 - 8x + 7` 是否永远成立

如果  `sp => y = x^2 - 8x + 7` 永远成立，说明程序永远正确。即对于任何满足初始条件的输入，我们都能100%保证能得到满足最终状态的值。

我们用数学的力量，避免了对无限多数据的验证！

我的理解结束。◀


![Pasted image 20241214123636](README.assets/Pasted image 20241214100236.png)

程序P如何把谓词I变为谓词R？

定义：程序P的最强后置条件（strongest postcondition, sp）就是一个谓词，它描述了所有可能的**终止状态**，这些状态由程序 P 从满足初始条件 I 的初始状态转换而来。
强后置条件只取决于程序 P 和初始条件 I，与后条件R无关。

对于上图中 I := x > z + 5 的例子：
程序结束之后，所有 x 的值都自增3，所以如果 I := x > z + 5 满足，那么 sp(P, I) = x > z + 8

> 部分正确性定理

如果存在程序P和3个谓词：

I - 前条件，程序在运行前应该满足的条件

R - 后条件，程序结束后的期望满足条件

<span style="color: #B51515">sp(P, I) - 最强后条件，他描述了所有可能的 终止状态 ，这些状态由程序 P 从满足初始条件 I 的初始状态转换而来。</span>
那么这条定理成立：**如果 sp(P, I) => R，则 { I } P { R }。**

证明略。

> 如何证明程序P的正确性？

步骤：

1. 找到最强后条件 sp(P, I)
2. 检查 sp(P, I) => R 是否成立

由此我们可以得出：

- `{False} P {ψ}` - 如果前置条件是 False，那么对于任何程序 P，它的后置条件都是成立的

  这是一个永真三元组，因为前置条件是 False，意味着程序 P 永远不会被执行，所以任何后置条件都无所谓，所以这个三元组在任何情况下都是成立的

- `{φ} P {True}` - 对于任何程序 P 和任意的前置条件 φ，当程序 P 执行完毕后，后置条件“True”总是成立

  这个三元组也是永真的，因为后置条件是 True，表示任何结束状态都是符合的。因此，**无论前置条件或程序的具体形式如何**，后置条件为“真”总是成立的

> 如何求取程序的最强后条件 sp(P, I)?

需要根据程序的复杂程度分情况讨论：

- 赋值语句
- 顺序结构
- 分支结构
- 循环结构

#### (1) 赋值语句

- 形式：x := e
- 规则：
  - 将初始条件 I 中的变量x替换成表达式 e
- 计算方法：
  - `sp(x:=e,I)=I[x↦e]`
  - 其中`I[x↦e]`表示将 I 中所有出现 x 的地方替换成 e

- 例子：

```
{x > 0}
x := x + 1
```

- 初始条件：I: x > 0
- 赋值后 sp(x:= x + 1, x > 0) = x - 1 > 0
- 化简得 sp = x > 1

计算步骤（我个人的理解）：

<img src="README.assets/Pasted image 20241214105929.png" alt="Pasted image 20241214123636" style="zoom:50%;" />

判断程序是否满足部分正确性的例子：
![Pasted image 20241214123636](README.assets/Pasted image 20241214111233.png)

我的求解过程：
![Pasted image 20241214123636](README.assets/Pasted image 20241214111357.png)

![Pasted image 20241214123636](README.assets/Pasted image 20241214111412.png)

答案：（见PPT[[Модуль 2. Дедуктивная верификация.pdf) p32）

<img src="README.assets/Pasted image 20241214123636.png" alt="Pasted image 20241214123636" style="zoom:67%;" />


#### (2) 顺序结构

- 形式：P1; P2 （两个程序顺序执行）
- 规则：
  - 先计算第一个子程序的最强后置条件 sp(P1, I)
  - 将其作为第二个子程序的前条件
  - 最终得到的结果是整个顺序结构的最强后条件
- 计算方法：
  - `sp(P1​;P2​, I) = sp(P2​, sp(P1​,I))`

示例：

```
I = {y + x > z + 1}
x := 2z + x;
y := y - x;
```

我的求解步骤：

<img src="README.assets/Pasted image 20241214114148.png" alt="Pasted image 20241214123636" style="zoom:67%;" />

答案：（见PPT[[Модуль 2. Дедуктивная верификация.pdf) p37）

<img src="README.assets/Pasted image 20241214114211.png" alt="Pasted image 20241214123636" style="zoom:67%;" />

如果程序由多个子程序组成：`[s1; s2; s3; s4; s5]`
那么：`sp([s1; s2; s3; s4; s5], I) `
`=== sp(s5, sp([s1; s2; s3; s4]))` 
`=== sp(s5, sp([s4], [s1; s2; s3])))` 
`=== ... `
`=== sp(s5, sp([s4], sp([s3], sp([s2], sp([s1], I)))))`

用自底向上的方法，先求最里面的`sp([s1], I)`，再求`sp([s2], ...)`，再求 `sp([s3], ...)`，再求 `sp([s4], ...)`，最后求 `sp([s5], ...)`。


#### (3) 分支结构

- 形式：if C then P1 else P2
- 规则：
  - 计算分支条件成立时的最强后置条件 `sp(P1, I ∩ C)`
  - 计算分支条件不成立时的最强后置条件 `sp(P2, I ∩ not C)`
  - 将两个结果的析取作为整个分支结构的最强后置条件
- 计算方法：
  - `sp(if C then P1 else P2， I) = sp(P1, I ∩ C) ∪ sp(P2, I ∩ not C)`
- PPT 中的位置：
  - <img src="README.assets/Pasted image 20241214122206.png" alt="Pasted image 20241214123636" style="zoom:67%;" />
- 例子：计算这个程序的最强后置条件

```I = {x >=0}
P = if x > 0
	then x := x + 1
	else x := x - 1
```



<img src="README.assets/Pasted image 20241214123636.png" alt="Pasted image 20241214123636" style="zoom:50%;" />


#### (4) 循环结构

- 形式：while C do P
- 规则：
  - 循环结构的最强后置条件需要依赖循环不变式 $I_{inv}$ (инвариант)
    - *инвариант цикла - утверждение, которое остается истинным при всех прохождениях цикла*
  - 循环终止时的条件为 $\neg C$，因此终止状态应满足 $I_{inv} ∧ ¬C$
- 计算方法
  - 定义循环不变式 $I_{inv}$，确保 `sp(P, I_inv) => I_inv`
  - 最强后置条件为：$$sp(while\ C\ do\ P,\ I)=I_{inv}∧¬C$$
- PPT中的表述：![Pasted image 20241214123636](README.assets/Pasted image 20241214125539.png)
- ![Pasted image 20241214123636](README.assets/Pasted image 20241214132731.png)
  - 如果构造了循环不变量 A，则循环程序的证明就简化为三个定理的证明：
    - `Т1: sp( [s1; s2 ], I ) => A`
    - `Т2: sp( [B1+; s3], A) => A`
    - `Т3: sp( [B1- ; s4], A) => R`
  - 如果无法证明循环程序的部分正确性，那么要么该程序不正确，要么程序箭头上的语句（循环不变量）被错误地编写。

示例：证明一个阶乘程序的正确性

![Pasted image 20241214123636](README.assets/Pasted image 20241214134352.png)


我的求解过程：
![Pasted image 20241214123636](README.assets/5400145923125929457.jpg)

##### 这里的难题在于，循环不变式怎么找？

循环不变式的定义：

循环不变式（Loop Invariant）**是指在循环开始前、循环每次迭代时以及循环结束后，始终保持为真的某个条件或谓词。** 它用来帮助证明程序的正确性，尤其是证明程序在完成时是否满足后置条件。

循环不变式的找法：

找循环不变式通常遵循以下步骤：

1. **分析程序的目标：**

   - 确定程序的功能和目标是什么，比如计算阶乘、排序数组等。
2. **理解程序的状态变化：**

   - 观察程序中的变量在每次循环迭代时如何变化。
   - 需要找出一个条件，它在每次迭代后都为真，并且帮助描述程序的目标。
3. **验证初始条件和循环终止条件：**

   - 循环不变式应当在初始时成立，并且在每次循环执行后依然成立。
   - 循环退出时，不变式应有助于证明程序满足后置条件。
4. **使用归纳法：**

   - 通过归纳法来验证：假设不变式在某次迭代中成立，证明在下一次迭代中依然成立。



---

求解抛物线移动之后的图像，原理是求解程序的最强后置条件。【小测原题】

![Pasted image 20241214123636](README.assets/Pasted image 20241214115118.png)

在移动之前满足抛物线 `I = { y = x^2 - 6x + 2 }`，经过移动(程序) 之后会得到怎样的图像？
这个问题等价于，求解程序的最强后置条件。


---

{ I } S { R } – утверждение : “ Если состояние программы S завершается, то после завершения состояние S удовлетворяет постусловию R “

### wp (最弱前置条件)

wp(S,R) - максимально широкое предусловие, такое, что из любого состояния, удовлетворяющего wp(S,R), после завершения программы S состояние S будет удовлетворять R

**Определение.** Слабейшее предусловие wp(S, R) программы S задает множество ВСЕХ тех состояний S, из которых в результате выполнения S попадем в те состояния, которые удовлетворяют предикату R

**wp(P, Q)** 是程序 P 执行之前需要满足的最弱条件，使得程序 P 在执行后能够保证满足后置条件 Q。

简而言之：

- wp(P,Q) 是所有能够确保程序 P 执行完后满足 Q 的前置条件中最弱的一个。
- "最弱" 表示：它包含所有更强的前置条件（即满足 wp 的条件也满足所有更强的条件）。

例子：
![Pasted image 20241214123636](README.assets/Pasted image 20241216015803.png)

w(S, R) = (x + 3) > z + 5

定理：`{ I } S { R }` 成立当且仅当 `I => wp(S, R)`

> 怎样求 wp？

#### 如何求程序的最弱前置条件 wp(S,R)wp(S, R)

根据 **PPT 3: Модуль 3. Темпоральные логики** 提供的方法，对于一个程序 SS，给定前条件 II 和后条件 RR，求解最弱前置条件 wp(S,R)wp(S, R) 可以分不同的程序结构讨论。

##### (1) 赋值语句

![image-20241221024013823](README.assets/image-20241221024013823.png)

##### (2) 顺序结构

![image-20241221024025835](README.assets/image-20241221024025835.png)

![image-20241221024038872](README.assets/image-20241221024038872.png)

![image-20241221082309510](README.assets/image-20241221082309510.png)

![image-20241221082346677](README.assets/image-20241221082346677.png)

##### (3) 条件分支

![image-20241221024056009](README.assets/image-20241221024056009.png)

![image-20241221024106958](README.assets/image-20241221024106958.png)

![image-20241221082516008](README.assets/image-20241221082516008.png)

##### (4) 循环结构

![image-20241221024125055](README.assets/image-20241221024125055.png)

![image-20241221024132825](README.assets/image-20241221024132825.png)

总结

1. **赋值语句：** 用目标变量的表达式替换后置条件。
2. **顺序结构：** 递归计算子程序的 wpwpwp。
3. **条件分支：** 分别计算分支条件下的 wpwpwp 并合并。
4. **循环结构：** 利用循环不变式计算终止条件下的 wp。



> 例题

例题1：对于程序 S，前置条件 I 和后置条件 R，使用最弱的前置条件 wp 找到表达式 E，使得 S 正确

![image-20241221082624799](README.assets/image-20241221082624799.png)



例题2：证明swap函数

![image-20241221082810312](README.assets/image-20241221082810312.png)



---

> 时态逻辑

- 时序逻辑是一种扩展的逻辑形式，用于描述系统的时间行为。
- 它允许表达系统状态随时间的变化，例如某个属性在未来是否成立。
- **LTL（线性时序逻辑）：** 表达“在未来某时刻某事件必然发生”。
- **CTL（分支时序逻辑）：** 表达“从当前状态出发，有一个路径满足某条件”。
- 应用场景：常用语验证交互式系统
  - 验证系统的安全性（Safety）。
    - 验证系统的活性（Liveness）。



### Структура Крипке

定义：Kripke 结构是描述系统状态及其状态间转移的数学模型，用于形式化验证和时序逻辑公式的语义解释。它是时序逻辑（如 LTL 和 CTL）的基础。

时序逻辑传统上是由克里普克结构进行解释的。

![Pasted image 20241214123636](README.assets/Pasted image 20241216100617.png)

Kripke 结构由以下三部分组成：

1. 状态集合 S，其中初始状态集合S0是S的子集
2. 转移关系集合 R：描述状态间可能的转移。
3. 原子命题集合 AP：系统中的原子命题集合。
4. 标签函数 L：L(s) 表示在状态 s 下为真的命题。

#### Kripke 结构的图形表示

在 Kripke 结构中：

- **状态**：用圆圈表示（如 s0,s1,s2​）。
- **转移关系**：用有向边连接状态（如 s0→s1​）。
- **标签**：标注在状态内的原子命题（如 p,q）。


## Темпоральные логики

> Модальность 模态，modus

Модальная логика - любая формальная логическая система, в которой присутствуют модальные операторы. 
模态逻辑是其中存在*模态运算符*的任何形式逻辑系统。

Примеры модальных операторов：模态运算符

- Mp：“возможно, что р истинно“ p可能为真
- Lp：“р обязательно истинно” p必然为真
- Fp：“когда-нибудь в будущем р будет истинным” 在未来p将会为真
- Gp：“р будет истинным всегда в будущем” p在未来永远为真
- $K_Ap$： “агент А знает, что р истинно” 代理人知道p为真
- $B_Ap$：“агент А считает (полагает), что р истинно” 代理人相信p为真

时态逻辑是模态逻辑中的一种。

### LTL

LTL 的逻辑公式描述系统在**线性时间**上的行为。

LTL 是一种形式语言。形式语言有语义和语法。

我们先说语法：

LTL公式 φ 是指：

- 原子语句 p, q ... 
- [逻辑运算符](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6 "逻辑运算符")：[非](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%9D%9E "逻辑非")（¬）、[与](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%90%88%E5%8F%96 "逻辑合取")（∧）、[或](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E6%9E%90%E5%8F%96 "逻辑析取")（∨）、[条件](https://zh.wikipedia.org/wiki/%E5%AE%9E%E8%B4%A8%E6%9D%A1%E4%BB%B6 "实质条件")（→）
- 时态运算符：**X**，**F**，**G**，**U**，**R**等
  <img src="README.assets/Pasted image 20241216110105.png" alt="Pasted image 20241214123636" style="zoom:50%;" />

其他时态运算符：
<img src="README.assets/Pasted image 20241216110221.png" alt="Pasted image 20241214123636" style="zoom:50%;" />

总之：

- LTL 有4个模态运算符：F, G, U, X
  - `X p`：在下一个状态，`p` 为真。
  - `F p`：在未来的某个状态，`p` 为真。
  - `G p`: 包括现在的所有未来状态，`p` 为真。（**包含现在！！**）
  - `p U q`： `p` 一直为真，直到 `q` 为真。
- F, G 通过 U 来表示：
  - $Fp \ \equiv true\ U\ p$
  - $Gp \ \equiv \ \neg F \ \neg p$

语义上，每个时态运算符 X, F, G, U, R, W, M 都有对应的含义：

<img src="README.assets/image-20241217014855753.png" alt="image-20241217014855753" style="zoom: 67%;" />

<img src="README.assets/image-20241217015902701.png" alt="image-20241217015902701" style="zoom:67%;" />

这里特别强调pUq的判断：

<img src="README.assets/image-20241220163145495.png" alt="image-20241220163145495" style="zoom:60%;" />

- G р - *всегда в будущем* *р*
- F р - *хотя бы раз* *в будущем* *р*
- ¬Fр– *никогда в будущем* *р*
- GFр – *бесконечно много раз в будущем*
- FGр – *с какого-то момента постоянно* 
- p => Fq – *на* *р* *в* *s**0* *когда-нибудь в будущем будет реакция* *q* 
- G[p => Fq] – *всегда* *на* *р* *будет реакция* *q* 

<img src="README.assets/Pasted image 20241216113229.png" alt="Pasted image 20241214123636" style="zoom:60%;" />

解释：对于一条路 σ，定义σ 满足公式p为 `σ |= p`。归纳如下：

1. σi |= p：在状态si的时候语句p为真
2. σi |= ¬p：在状态si的时候语句p为假
3. σi |= p ∨ q：在状态si的时候，p ∨ q 为真
4. σi |= X p：在si的下一个状态(si+1) p为真
5. σi |= p U q：在si之前, p 一直为真，从si开始(包括si) q一直为真
6. σi |= G p：从si开始(包括si) p一直为真
7. σi |= F p：从si开始(包括si) 至少存在一个 p 为真的状态

LTL通过X进行定义(Определение операторов LTL через neXtTime)：

<img src="README.assets/image-20241217235748850.png" alt="image-20241217235748850" style="zoom:50%;" />

LTL的递归定义：(Рекурсивное определение операторов LTL)

<img src="README.assets/image-20241217235738261.png" alt="image-20241217235738261" style="zoom:50%;" />



F 和 G 之间的关系：

Fp = ¬G¬p

Gp = ¬F¬p

<img src="README.assets/Pasted image 20241216115557.png" alt="Pasted image 20241214123636" style="zoom:50%;" />

> LTL等价式

<img src="https://github.com/nekosilverfox/Model-Checking/blob/main/doc/img/image-20241219193327154.png?raw=true" alt="image-20241219193327154.png" style="zoom:80%;" />

> LTL 公式的语义解释（例子）

- *Если сообщение* **m** *поступило на вход в канал, то когда**-**нибудь* *в будущем* **m** *появится на выходе*：`G[на_вход(m) -> XFна_выход(m)]`
- Лифт никогда не пройдет мимо этажа n, от которого поступил еще не удовлетворенный запрос ：（没懂）
  - <img src="README.assets/image-20241220165658640.png" alt="image-20241220165658640" style="zoom:50%;" />

- *пока живу – надеюсь*：`G(я_живу -> я_надеюсь)`
- *“Мы придем к победе коммунистического труда!”*：`Fp, где p - 共产主义胜利`
- *“Сегодня он играет джаз, а завтра Родину продаст!”* ：`G(он_играет_джаз => XFон_продает_Родину)`
  - 用 XF 表示下一个状态起的未来
- Пусть р = “*я люблю Машу*”, q =“*я люблю Дашу*”
  - Fp – *“когда-нибудь я обязательно полюблю Машу”* 将来我会喜欢上Masha
  - FGp - *“когда-нибудь в будущем я полюблю Машу навечно”* 将来我一定会永远爱Masha
- “*Раз* *Персил* *– всегда Персил*” 用过一次Persil，就一直会用Persil： G(*Персил* Þ G*Персил*) – *раз попробовав, будешь использовать всегда*
- 感受差异：
  - p=>Fq – *на* *р* *в* s0 *когда-нибудь в будущем будет реакция*q. ：如果在s0满足p，那么将来一定会响应q
  - G[p=>Fq] – *всегда* *на* *р* *будет реакция* *q* ：只要输入p就会响应q
- 【仔细体会】*“Любой запрос к ресурсу будет обязательно* *явно подтверждаться* *либо явно отклоняться до момента выставления нового запроса”* - `G( request => (X!request) U (reject xor confirmed) )`
  - **`request`**：表示当前有一个请求发生
  - **`=>` (蕴含)**：如果有请求，则后续条件必须成立。
  - `U`左侧条件为 `(X!request)`，右侧条件为 `(reject xor confirmed)`。
  - **`reject xor confirmed`**：表示最终状态必须是 `reject`（拒绝）或 `confirmed`（确认），但不能两者同时为真。
- “*Если запрос* *р* *к ресурсу* *выставляется* *неопределенно часто, то разрешение* *q* на его использование тоже выдается неопределенно часто”. GFp => GFq
  - выставляется неопределенно часто - GF

- Обозначение:  q = *‘**я живой**’*
  - *Я живу сейчас, и когда-то**,* *в какой-то один из* *следующих* (X) *моментов времени* *обязательно кончу жить – умру*     q**U**!q. 
  - *До конца жизни я живу непрерывно, но уж если умру, то навсегда, не воскресну* **G**(q => X!q ).



练习题：Выразить в LТL свойства: // 没答案

1. *Если произойдет* *р, то в будущем* *q* *никогда* *не случится.*

2. *Если произойдет* *р, то когда-нибудь в будущем выполнится* *q, а сразу после этого произойдет* *r.*

3. *Если случится р, то в будущем обязательно случится* *q, а между р и* *q* *не будет выполняться* *r*.

4. *В будущем* *р* *может случиться не более, чем один раз.*

5. *В будущем* *р* *случится ровно два раза.*

6. *Я в своей жизни выйду замуж не более двух раз.*

7. *Событие* *q* *всегда непосредственно следует за событием* *p.*

8. *Событие* *q* *всегда непосредственно* *предшествует событию* *p.*

Примеры проверяемых свойств (LTL)

- GF DeviceEnabled：событие *DeviceEnabled* выполняется неопределенно часто
- 【仔细体会】G[(p -> X(!q U r ))]：после того, как p выполнился, q не выполнится, пока не станет активным r
- G[ p -> Xq & XXq & XXXq ]: после того, как сигнал p стал активным, со следующего такта сигнал q будет активным по крайней мере три такта
- 【仔细体会】G ( updateAx ∧ F readBx -> !readBx U flushAx): между моментом, когда процесс А изменяет значение переменной x (updateAx), и моментом, когда В читает значение этой же переменной (read_Bx), х должно быть вытолкнуто из кэша процессом А (flashAx)
- G (req -> X(req U ack))：запрос не будет снят, пока на него не придет подтверждение
- 【仔细体会】G[q -> X [(!p U r) ∨ G!r] ] ：nмежду q и r событие р не выполняется
- (Lecture9, slide8)



Пример спецификации требования (LTL)

- Как выразить свойство P:“*запрос* req *в конце концов приведет к получению* ack” ：**G(** **F**req & (req -> **ХF**ack))
- 【仔细体会】“*Событие* *р* *не должно выполняться между событиями* *q* *и* *r*”：![image-20241220202721306](README.assets/image-20241220202721306.png)

解释：这句话暗示了两点：

- q发生之后，r最终一定会发生
- q和r之间，!p一直会成立，从图片中可以看到，!p直到r之前的时刻一直都成立

根据这两点：

- 先描述q到r：q^XFr - 当前状态满足q，而且从当前状态触发的下一个状态开始，最终会发生r
- 再描述q到r之前的这段路径：很明显在这段路径上!p会一直成立，直到遇到一个r。所以公式可以写为：X(!pUr)。但这还没完，因为q所在的点也必须满足!p，所以q~r这段路径的完整描述是：!p^X(!pUr)
  - 在这里我一开始会很奇怪：!p^X(!pUr) 为什么不干脆合并成`!pUr`？现在我理解：如果写成了!pUr就会导致r直接发生在了q上，这样的话就不可能描述出“между событиями* *q* *и* *r*”的情况了。因此得出一个结论：如果有 между a и b,那么b不可能与a同时发生！
- 合并一下前两点：
  - **前提：** 如果 q 在当前状态发生，且从下一个状态开始，最终会发生 r。
  - **结论：** 那么，当前状态和 r之间的所有状态必须满足 ¬p。



Структурирование шаблонов – типы требований

<img src="README.assets/image-20241220205858677.png" alt="image-20241220205858677" style="zoom:60%;" />





> Kripke 结构的运算

Kripke 结构是无限循环的。要怎么用有限的方式计算？

![Pasted image 20241214123636](README.assets/Pasted image 20241216120834.png)

Развертка структуры Крипке может быть использована как модель ветвящегося времени 
Kripke 结构可以展开成分支时间模型。

**分支时间模型** 就是将 Kripke 结构的状态和转移关系展开，形成树状结构，称为 **状态空间展开**（State Space Unfolding）。

> Развертка структуры Крипке Kripke 结构的展开



### CTL*

> CTL* // Темпоральные логики ветвящегося времени // Computational Tree Logic

CTL* 公式描述**计算树（Computation Tree）** 的性质，计算树由 Kripke 结构生成。首先在 Kripke 结构中指定一个状态为初始状态，接着将这个结构展开成以此状态作为根的无限树。**计算树展示了从初始状态开始的所有可能的执行路径。**

![Pasted image 20241214123636](README.assets/Pasted image 20241216122134.png)

> CTL 和 CTL* 的区别

- **定义：** CTL* 是 CTL 和 LTL（线性时序逻辑）的统一扩展，允许更复杂的组合表达。
- **特点：**
  - CTL* 的路径量词（AAA、EEE）和时序操作符（X,F,G,UX, F, G, UX,F,G,U）可以分离，可以灵活地组合。
  - CTL* 允许在路径上编写任意的 LTL 公式，同时也支持分支逻辑的表达能力。
- **公式结构：**
  - CTL* 公式的基本形式：**路径量词 + LTL 公式**。
  - 示例：`A(GFp), E(G(p∨Fq)), G(Fp)`

| **特性**             | **CTL**                                            | **CTL***                                |
| -------------------- | -------------------------------------------------- | --------------------------------------- |
| **路径量词与操作符** | 必须成对出现（例如：AX,EF,AGAX, EF, AGAX,EF,AG）。 | 可以分离，路径量词与 LTL 公式自由组合。 |
| **公式的表达能力**   | 更受限制，公式较为简单。                           | 更强大，支持嵌套和任意组合的公式。      |
| **示例**             | AG(p→AFq)                                          | G(Fp∨A(Gq))                             |

<img src="README.assets/Pasted image 20241216125505.png" alt="Pasted image 20241214123636" style="zoom:50%;" />
可以认为 `CTL` 是 `CTL*` 的子集


> `CTL*` 允许的运算符

<img src="README.assets/Pasted image 20241216122813.png" alt="Pasted image 20241214123636" style="zoom:50%;" />

> Семантика CTL* на структурах Крипке // CTL* 的语法

> `CTL*` 状态公式语法
> <img src="README.assets/Pasted image 20241216124000.png" alt="Pasted image 20241214123636" style="zoom:50%;" />

- M, s |= p ： p 在 s状态下为真
- M, s |= ¬p： p 在 s状态下为假
- M, s |= p ∨ q： 在s状态下，q或p为真
- M, s |= Ep：从状态s开始(包含s)，存在一条路径(时刻)使得p满足
- M, s |= Ap：从状态s开始(包含s)，所有路径(时刻)都满足p

> `CTL*` 路径公式语法
> <img src="README.assets/Pasted image 20241216124545.png" alt="Pasted image 20241214123636" style="zoom:50%;" />

![Pasted image 20241214123636](README.assets/Pasted image 20241216124745.png)

---

### CTL

В CTL каждый темпоральныйоператор предварен квантором пути. ВСЕ ФОРМУЛЫ CTL –формулы СОСТОЯНИЙ. 

在 CTL 中，每个时间运算符前面都有一个路径量词。所有 CTL 公式都是 状态 公式。

> CTL 语法

共有4个运算符 **X, F, G, U**，2个路径量词 **E, A**。组合使用，所以一共有 8 个 CTL 操作符：

AX, EX,

AF, EF,

AG, EG,

AU, EU

- `AG p`: 在所有路径上的所有状态中，`p` 都为真（`p` 在所有未来都成立）。
- `EF p`: 存在一条路径，在该路径的某个未来状态，`p` 为真（`p` 在某个未来状态成立）。

CTL 的一个关键特性是它的表达力不仅考虑了单一未来的线性时间，还能够表达不同路径的分支未来。例如，“所有可能的未来中某个状态必须满足条件” 是 CTL 能表达的一个经典性质。

合法公式：`E[cUb], A[pU(rEFq)], EXpEXq, EGАFp, ...`

CTL 不合法的公式有：`EGFp, A[ Xp∨ XXr], …`

非形式化的 CTL 公式定义：
![Pasted image 20241214123636](README.assets/Pasted image 20241216125320.png)

![image-20241218023208760](README.assets/image-20241218023208760.png)

![image-20241218023230180](README.assets/image-20241218023230180.png)

形式化定义CTL：

![image-20241218024211812](README.assets/image-20241218024211812.png)



其他表示方法：

在模型验证中，表达式 M,s⊨Aψ 表示在模型 M 的状态 s 下，“**总是**”满足公式 ψ，也就是说，沿着从 s 出发的 **所有路径（A，代表 All）**，公式 ψ 都成立。

具体解释如下：

- **M**：这是一个 Kripke 结构（或状态转换系统），用来表示模型的所有状态及其状态间的转移关系
- **s**：模型 M 中的**一个特定状态**
- **A**：这是 CTL（计算树逻辑）中的路径量词 “所有（All）”。它表示从当前状态出发的所有可能路径。
- **ψ**：这是一个逻辑公式，可以描述状态的某种性质或一系列性质

因此，整个公式 M,s⊨Aψ 表示：

在模型 M 的状态 s 中，沿着所有可能的路径，公式 ψ 都成立。换句话说，从状态 s 出发，不管未来的路径怎么发展，公式 ψ 在每条路径上都是成立的

> CTL 重要等式

<img src="README.assets/image-20241220180811453.png" alt="image-20241220180811453" style="zoom:50%;" />

<img src="README.assets/image-20241221083522035.png" alt="image-20241221083522035" style="zoom:60%;" />



> CTL 公式例子

р = “*Я люблю Машу*”

- AGp: “*Я люблю Машу, и, что бы ни случилось, всегда (А), во всех ситуациях (**G**), я буду любить Машу”*
- AFAGp：“*В будущем что бы ни случилось (А) , я когда-нибудь* *(F) полюблю Машу навсегда* *(G)”*
- EFp：“*Существует такое развитие событий* *(E)**, что в будущем (F) я полюблю Машу”*



- AG EF EGp：*В любом состоянии вашей жизни (сколько бы мы ни грешили* *A**G**) существует такой путь (**Е**), что на нем в конце концов (**F**) попадем в состояние, с которого p выполняется” (**E**G)*
- AGAGrestart: n*на* *всех* *путях из любого состояния этих путей обязательно вернемся в состояние* *рестарта*
- AFAG (x<y)：*все вычисления когда-то в будущем достигнут такого режима, в котором соотношение* *x<y* *выполняется постоянно*
- !EF(int >0.01)：не существует такого режима работы, при котором интенсивность облучения пациента превысит 0.01 рентген в сек.
- AG (req **=>** A (req U ack)):*во всех режимах после того, как запрос* *req* *установится, он никогда не будет снят, пока на него не придет* *подтверждение* 在所有模式下，req请求一旦建立，在收到确认之前永远不会被清除
- 【仔细体会】E[ p U A [q U r] ]：cуществует режим, в котором условие p будет истинным с начала вычисления до такого состояния, с которого на всех путях q станет непрерывно активным (истинным) до выполнения условия r 
- AXp: p выполняется во всех *следующих* состояниях (непосредственных потомках текущего состояния)
- EXp: формула p выполняется хотя бы в одном *следующем* состоянии
- AFp (*неизбежно* p) - на всех путях из текущего состояния формула p *когда-нибудь* выполнится
- EFp (*возможно* p) - из текущего состояния существует 
   путь, на котором формула j *когда-нибудь* выполнится
- AGp - на всех путях из текущего состояния во всех состояниях этих путей формула p выполняется
- EGp - существует путь из текущего состояния, 
   во всех состояниях которого формула p выполняется
- A(pUq) - на всех путях из текущего состояния когда-
   нибудь выполнится формула q, а до этого во всех 
   состояниях выполняется формула p
- **E**(j1**U**j2) – из текущего состояния существует путь, на котором когда-нибудь выполнится j2, а до этого во всех состояниях этого пути выполняется j1

常用的：AF，EF，AG，EG

Примеры проверяемых свойств (CTL)

- 【部分正确性的CTL表述】at_start ∧ j => AG(at_finish => y)：

  - частичная корректность: если в начале программы (at_start ) выполняется предусловие j, то на любом вычислении (AG) если программа завершается (at_finish), то выполняется постусловие y

- AGAF Restart：при любом функционировании системы (на любом пути) из любого состояния системы всегда обязательно вернемся в состояние рестарта

- AG EF Restart：nпри любом функционировании системы (на любом пути) из любого состояния системы существует путь, по которому можно перейти в состояние рестарта

- E[ p U A [q U r] ]：cуществует путь, на котором р выполняется до тех пор, пока событие q станет выполняться до выполнения r на всех путях

  

## MC for CTL

> Алгоритм Model checking для проверки выполнимости формул CTL

Наша задача – рассмотреть алгоритм Model checking для логики CTL

目标：验证 **CTL（分支时序逻辑）** 公式在 **Kripke 结构** M 上的可满足性。
**任务：** 确定给定的 Kripke 结构 M=(S,R,L) 和状态 s0​ 是否满足公式 φ，即：$M,s_0 |= \phi$

CTL 公式的特点：

- 路径量词：A, E
- 时序操作词：X, F, G, U
- CTL 公式必须满足路径两次与时序操作符配对的规则，比如
  - AXp, EFq, AGp, `E[pUq]`

==方法：基于 Kripke 结构的验证方法==【<span style="color: #B51515">必考！Exam 第一题！</span>】

形式化表达问题：

<img src="README.assets/Pasted image 20241216194346.png" alt="Pasted image 20241214123636" style="zoom: 80%;" />

 *"Необходимо разработать алгоритм проверки выполнимости произвольной темпоральной формулы на любой структуре Крипке."*

![Pasted image 20241214123636](README.assets/Pasted image 20241216200614.png)

*Общая идея – структурная индукци*
*总体思想是结构归纳法*

*Формул – бесконечное число, но число типов подформул конечно! Они перечислены в ГРАММАТИКЕ языка*
*公式有无限多个，但子公式的类型数量是有限的！它们列在该语言的语法中*

步骤：

1. 为公式F构建语法树
2. 我们依次用在这些状态下为真的公式 Φ 的子公式来标记（标记）克里普克结构的所有状态。
3. 在算法结束时，如果Kripke结构M的<span style="color: #B51515">初始状态</span>标记为Φ，则在M上能满足公式Φ。

tbd_verification: Модуль 4. MC для LTL_1，p34页 中有一个例子：

<img src="README.assets/image-20241221083731379.png" alt="image-20241221083731379" style="zoom:50%;" />

现有一个CTL公式：`Ф = E [EX not p U AF (q ∩ r) ]`
和一个模型（自动机）：

![Pasted image 20241214123636](README.assets/Pasted image 20241216211100.png)

检查在模型的哪些状态下满足公式`Ф`？
先说结论，再说实操。结论是递归分解成最小的CTL公式，然后自底向上检查每个状态满足哪些CTL公式。最后的关键是看公式 `Ф` 是否落在 s0上。如果落在了 s0 则说明模型能完成 `Ф` 公式。

以这个例子探讨一下这类题型的做法：实操三步走。

1）公式转化成语法树：![Pasted image 20241214123636](README.assets/Pasted image 20241216212555.png)

2）列出语法树中所有出现的公式：
![Pasted image 20241214123636](README.assets/Pasted image 20241216212617.png)

3）从f1开始到fn(`Ф`)，检查自动机的每个状态可以满足哪些公式：
![Pasted image 20241214123636](README.assets/Pasted image 20241216212700.png)

4）最后可以得出结论，在模型的s0, s1, s2状态下都满足公式 f8（`Ф`）


*Для заданных структуре Крипке и формулы Ф логики CTL нужно уметь строить множества состояний, в которых выполняется формула Ф (и все ее подформулы).*

*Это является стандартным умением, которое будет проверяться у каждого студента.* 

补充：怎样检查各个公式：EX、AF、EU   --------> 【重要！】

<img src="README.assets/image-20241217231723427.png" alt="image-20241217231723427" style="zoom:50%;" />

<img src="README.assets/image-20241217231735231.png" alt="image-20241217231735231" style="zoom:50%;" />

<img src="README.assets/image-20241217231747376.png" alt="image-20241217231747376" style="zoom:50%;" />



## 🔺MC for LTL

> Model checking для формул LTL

可以通过X来定义LTL的时间操作符（U, F, G）：

![image-20241217020411818](README.assets/image-20241217020411818.png)

F与G之间的关系：

![image-20241217020723303](README.assets/image-20241217020723303.png)

遵循“德摩根定律”

#### LTL 运算符的语义

假设存在一条路径σ=s0 s1 s2 ...

那么 $\sigma_i |= \phi$ 表示：在状态 si 中命题 φ 为真

![image-20241217021035626](README.assets/image-20241217021035626.png)



定理：*Формула LTL выполняется на структуре Крипке М, если она выполняется **на любом пути (вычислении)**, начинающемся в начальном состоянии М*

*LTL 公式在 Kripke 结构 M上成立，当且仅当它在从M的**初始状态**开始的所有路径（计算）上都成立。*

- 从 Kripke 结构 M 的初始状态 s0 出发，可能存在多条路径（状态序列），每条路径代表系统的一种可能的执行或行为。

- 公式在 **结构 M** 上成立，意味着公式必须在 **所有从初始状态出发的路径** 上都为真。
  换句话说，不能有一条路径使公式不成立。



与其验证所有路径都符合LTL公式，不如找到一条路径不符合LTL公式。如果找到了则LTL不在模型上成立，如果找不到则LTL在模型上成立。



![image-20241217205441824](README.assets/image-20241217205441824.png)

形式化语言生成的字符串是长度是有限的。可以通过有限自动机（如 DFA、NFA）进行验证字符串是否符合词法。

Omega语言生成的字符串长度是无限的！它的字符串只能通过通过 **Büchi 自动机** 或 **ω-自动机** 来验证和识别。



属性的描述并不是针对”状态“(s0 s1 s2 s3 s1 s2 ...)，而是针对”轨迹“(`{p,q} {q,r} {r} {r} {} {q,r} ...`)。

![image-20241217210024633](README.assets/image-20241217210024633.png)

要判断一个LTL公式是否在所有路径上满足属性，重点是找出所有“轨迹”，然后判断每条“轨迹”是否符合属性。

轨迹的数量是无穷的。

![image-20241217210535638](README.assets/image-20241217210535638.png)

模型M的轨迹集合A在上图左，不满足公式φ的轨迹集合B在上图右。我们要把两个图的轨迹相交，看看有没有交集。如果有交集则说明模型中有不符合φ的轨迹的轨迹存在，则 M|=φ 不成立。

那怎么计算集合A、B呢？

方法就是使用Buchi自动机。Buchi自动机可以证明无穷序列。([[Lecture 6 Verification LTL 2]] slide24)



### LTL 模型检测的基本思想

// Алгоритм Model Checking для формул LTL    ----------> 【重要！】

<img src="README.assets/image-20241221084247028.png" alt="image-20241221084247028" style="zoom: 80%;" />

1. **Структура Крипке M -> автомат Бюхи BM:**

   - **Kripke 结构 M：**
     Kripke 结构表示系统的状态集合及状态间的转移关系。
   - **Büchi 自动机 BM：**
     从 Kripke 结构 M可以构建一个 **Büchi 自动机 BM**，其接受所有可能的 **轨迹**（无限状态序列），这些轨迹表示 Kripke 结构中的状态路径。

2. **Формула Ф LTL -> автомат Бюхи B¬Φ:**

   - **LTL 公式 Φ：**
     要验证的线性时序逻辑（LTL）公式。
   - **B¬Φ：**
     将 **LTL公式 Φ** 转换为一个 **Büchi 自动机**，但这个自动机接受 **不满足公式 Φ** 的所有路径（**NECORРЕКТНЫЕ 轨迹**）。
   - 重点：
     B¬Φ 接受的是 **不满足公式 Φ** 的轨迹。

3. **Строится автомат BM ⊗ B¬Φ:**

   - 将 **BMB_M** 和 **B¬Φ** 进行 **同步组合（交互）**，得到新的 **Büchi 自动机 BM ⊗ B¬Φ**。
   - 作用：
     - 这个自动机接受 **Kripke 结构 m** 上的轨迹，且这些轨迹在 **LTL 公式 Φ** 下是 **不满足条件的**（错误路径）。
     - 等价于计算 BM ∩ B¬Φ。

4. **Проверяется, допускает ли автомат BM ⊗ B¬Φ непустой язык:**

   - 检查自动机 

     BM ⊗ B¬Φ 是否 接受非空语言：

     - 如果存在一条路径被接受（即进入 **循环** 并包含一个 **接受状态**），说明存在一个 **不满足公式 Φ** 的路径。

   - 两种结果：

     - **非空语言：** 公式 Φ不满足 Kripke 结构 MM。
     - **空语言：** 公式 Φ满足 Kripke 结构 MM。

5. **LTL формула Φ выполняется для M, если и только если BM ⊗ B¬Φ допускает пустой язык.**

   - 结论：
     - 如果组合自动机 BM ⊗ B¬Φ 接受的语言为空（即不存在错误路径），则 LTL 公式 Φ在 Kripke 结构 MM 上成立。
     - 反之，如果语言非空，则公式不成立。

#### 🔺Автоматы Бюхи Büchi 自动机 

1. Автоматы Бюхи, их формальное определение, примеры.

2. Построение **по структуре Крипке** **M** такого автомата Бюхи ВM, который допускает все возможные вычисления структуры M.

3. Автомат Бюхи и формулы LTL. Алгоритм построения по формуле Ф автомата Бюхи $В_{\negФ}$

4. Синхронная композиция двух автоматов Бюхи. 

5. Алгоритм проверки пустоты языка, допускаемого автоматом Бюхи.

6. Buchi自动机的形式化定义和示例
7. 根据Kripke结构（模型M）构建 Buchi 自动机
8. 根据 LTL 公式构建 Buchi 自动机的算法
9. 两个自动机的同步合成
10. 检查 Buchi 自动机允许的语言的非空性的算法。



现在来认识一下Buchi自动机.

先来看正则表达式：

$$E::=∅ | ε | A | E+E’ | E.E’ | E*$$

这里的E*表示E可以重复有限次。但如果写成了：$E^\omega$ 则代表无限次重复。

如果L语言带上了 omega，则记为：$L^	\omega$ ，被称为omega语言。



Недетерминированный автомат Бюхи // 非确定性Büchi自动机 // NBA, Nondeterministic Büchi Automaton

NBA 的定义：

A **non-deterministic Büchi automaton**, later referred to just as a **Büchi automaton**, has a transition function which may have multiple outputs, leading to many possible paths for the same input; it accepts an infinite input if and only if some possible path is accepting.

NBA的形式化定义：

![image-20241218002728444](README.assets/image-20241218002728444.png)



##### Kriplke->Buchi自动机：（p33） 

// Построение по структуре Крипке M такого автомата Бюхи BM, который допускает все возможные вычисления структуры M

![image-20241218094844525](README.assets/image-20241218094844525.png)

![image-20241218094908864](README.assets/image-20241218094908864.png)

从别的PPT中读到的：

![image-20241219003203504](README.assets/image-20241219003203504.png)

![image-20241219003227510](README.assets/image-20241219003227510.png)

![image-20241219003234583](README.assets/image-20241219003234583.png)

![image-20241219003251840](README.assets/image-20241219003251840.png)

示例：【待补充】



##### Buchi自动机的同步积 (Синхронная композиция, A×B)

// Синхронная композиция двух автоматов Бюхи

两个Buchi自动机的同步乘积(Synchronous Product)

<img src="README.assets/image-20241219013337711.png" alt="image-20241219013337711" style="zoom:67%;" />

![image-20241220120959924](README.assets/image-20241220120959924.png)

![image-20241220121014761](README.assets/image-20241220121014761.png)

注意：

- 同步积中，只有两个子状态都是接受态，同步积状态才算可接受

例子1：

![image-20241220121025810](README.assets/image-20241220121025810.png)

例子2：

![image-20241220121545676](README.assets/image-20241220121545676.png)

同步积是泛化Buchi自动机(Обобщенный автомат Бюхи)

扩展：

###### Параллельная/Асинхронаая композиция КА (A||B)

![image-20241220121431998](README.assets/image-20241220121431998.png)



##### 🔺LTL->Buchi自动机

 // Автомат Бюхи и формулы LTL. Алгоритм построения по формуле Ф автомата Бюхи ВФ

Существует несколько алгоритмов построения автомата Бюхи по заданной формуле LTL,*Они называются* *LTL2Buchi.*

Сложность автомата Бюхи экспоненциальна относительно сложности формулы Ф

> 网站：http://www.lsv.fr/~gastin/ltl2ba/index.php

例子：根据LTL公式构造的Buchi自动机（好像更多的是根据经验，或者用网站生成）

<img src="README.assets/image-20241221084647408.png" alt="image-20241221084647408" style="zoom:67%;" />

<img src="README.assets/image-20241218100020319.png" alt="image-20241218100020319" style="zoom:67%;" />

<img src="README.assets/image-20241218100041715.png" alt="image-20241218100041715" style="zoom:67%;" />

![image-20241218100105746](README.assets/image-20241218100105746.png)



##### Buchi自动机语言的非空性

 // Проблема пустоты автомата Бюхи

omega字符串σ能被Buchi自动机A接受，当且仅当终止状态A在输入字符串时无限多次发生。

![image-20241218100706240](README.assets/image-20241218100706240.png)

如果从自动机的初始状态出发，存在一条到接受状态的路径，且该状态有自循环，那么说明Buchi自动机接受的语言非空。

Контрпример: цепочка, переводящая  автомат в цикл принимающих состояний

反例：将自动机转移到一个接收状态循环的字

检查 Büchi 自动机语言非空性的算法：

<img src="README.assets/image-20241219012710083.png" alt="image-20241219012710083" style="zoom:80%;" />

Каждая цепочка из начального состояния в ССК с принимающими состояниями  определяет **контрпример -- вычисление, на котором не выполняется Ф**

1. 找到所有强连通（ССК, Сильно связные компоненты）【即回路！环！】
2. 只保留包含了可接受终态的强连通
3. 检查是否存在从s0出发的包含可接受终态的强连通存在

如果不存在则说明 Büchi 自动机的语言为空。否则，每一个从初始状态到达接受终态的串都是自动机的语言。（即：一个不满足φ性质的反例！！）

> 在模型上验证LTL公式 例题

例1：

<img src="README.assets/image-20241218102511695.png" alt="image-20241218102511695" style="zoom:80%;" />

例2：

<img src="README.assets/image-20241218102523162.png" alt="image-20241218102523162" style="zoom:80%;" />



##Структуры Крипке как модели параллельных программ

【TBD】



## Применение ТЛ // Спецификация свойств параллельных программ?

- Примеры спецификации  требований на LTL *todo* 【重要！考题！】

- Примеры спецификации  требований на CTL![image-20241219141325064](README.assets/image-20241219141325064.png)

- Применение шаблонов спецификации  требований

`Dwyer M.B., Avrunin G.S., Corbett J.C. Property Specification Patterns for  Finite-state Verification // Proceedings of the 2nd Workshop on Formal  Methods in Software Practice. – 1998`

*Предлагается система шаблонов, которая помогает практическому  программисту точно специфицировать требования*

*Система шаблонов состоит из Типа и Области действия требований*

*Эта работа дает спецификацию на LTL и CTL каждого типа  требования для каждой области действия.*

*提出了一个模板系统，可以帮助实际程序员准确地指定需求。*

*模板系统由需求类型和范围组成*

*这项工作为每个范围的每个需求类型的 LTL 和 CTL 提供了规范。*

![image-20241219141833595](README.assets/image-20241219141833595.png)

![image-20241219142008468](README.assets/image-20241219142008468.png)

关于“出现(`Absence`)”的模板：

событие p не выполняется

![image-20241219142151158](README.assets/image-20241219142151158.png)

Требование всеобщностивыполнения события р  (`Universality`)

![image-20241219142138438](README.assets/image-20241219142138438.png)

Шаблон “существование”: событие p должно  выполниться,по крайней мере, один раз (`Existence`)

![image-20241219142245190](README.assets/image-20241219142245190.png)



- Формулировка ОБЩИХ требований к программным системам логического  управления, отражающих их ПРИРОДУ как систем ПАРАЛЛЕЛЬНЫХ  ВЗАИМОДЕЙСТВУЮЩИХ ПРОЦЕССОВ
  - Достижимость (reachability) – конкретное состояние может быть достигнуто： `EFφ`
  - Безопасность (safety)- нечто плохое никогда не произойдет ：`AG¬φ`
  - Свобода от дедлоков (deadlock freeness) – проверка блокировок：
  - Живость, живучесть (liveness) - нечто хорошее обязательно  произойдет (something good happens)：`AG(req -> AFresp )в CTL`, `G(req -> Fresp) в LTL`
  - Справедливость (fairness) – дополнительные ограничения：`GF succeed` 强公平性、弱公平性...

## Снмвольная верификация CTL

State explosion problem

Символьный подход и BDD: борьба с проблемой  взрыва числа состояний

- Как BDD используются для задания булевых функций,  используемых в MC?？

- Как построить структуру Крипке в BDD?
- Теория неподвижной точки преобразований множеств
  - Теорема Тарского о неподвижной точке



**Задача верификации**: Даны структура Крипке К и CTL-формула φ. Найти множество всех таких состояний s, для которых верно: К, s|=φ, т.е. те, для которых выполняется φ. Если начальное состояние принадлежит s, то К|=φ

**Алгоритм Model checking** сводится к нахождению подмножеств состояний К, для которых выполняются подформулы формулы φ

Строим булевы функции в форме BDD для: 

(а) множества начальных состояний К 

(б) множества переходов К

(в) множеств состояний К, в которых истинен каждый атомарный предикат

**Символьная верификация**:

所有状态子集（CTL φ） -> 布尔函数 -> BDD

### Как построить структуру Крипке в BDD



1. 真值表
2. 决策树
3. (reduce算法) ---> 决策图(BDD)

<img src="README.assets/image-20241221085243553.png" alt="image-20241221085243553" style="zoom:50%;" />





## Бинарные решающие диаграммы (BDD)



Как построить BDD по булевой функции 如何根据布尔公式构建BDD【考题】：

![image-20241221085431161](README.assets/image-20241221085431161.png)



## Вероятностная логика ветвящегося времени

一般的时间逻辑检查可达性，不具备定量分析。

PCTL是一种扩展的CTL，它引入了概率尺度。

也就是说PCTL里没有A和E，它把E和A替换成了概率：

<img src="README.assets/image-20241220004322190.png" alt="image-20241220004322190" style="zoom:70%;" />



【离散马尔可夫链的变体】Модификация дискретной Марковской цепи(время считается неявно дискретными переходами из состояния в состояние, как и в структуре Крипке)：

<img src="README.assets/image-20241220004810948.png" alt="image-20241220004810948" style="zoom:80%;" />

Можно считать эту модель расширением структуры Крипке к структуре Крипкепросто добавляются вероятности переходов  Pr(s,q) из p в q. Переходы считаем независимыми событиями.

**计算路径 σ 的概率**：

路径σ = s0 s1 s2 ...是一个有限的状态序列

Pr(σ) = Pr(s0 s1 s2 ...) = Pr(s0, s1) * Pr(s1, s2) * ...

### PCTL (Probabilistic CTL)

![image-20241220005221356](README.assets/image-20241220005221356.png)



如何分解 PCTL 公式？

<img src="README.assets/image-20241220005453432.png" alt="image-20241220005453432" style="zoom:80%;" />



Как понимать формулы путей вероятностной 
 логики ветвящегося времени (РСТL)?  如何理解PCTL中的【路径公式】？

![image-20241221085659106](README.assets/image-20241221085659106.png)

> 如何计算PCTL公式  $P_{~p}X\mu$ 的真值？

![image-20241220021134273](README.assets/image-20241220021134273.png)

- 需要构建“转移概率矩阵”A
- 然后用**矩阵左乘列向量**（矩阵每一行乘以列向量，得到结果的一个元素），列向量的元素如果满足了条件 **μ** 则记作1，否则记为0
- 得到的行向量对应位置就是所处状态经过==往下运行1步后满足公式 μ==（Xμ）的概率



> 如何计算 PU 的真值？【重要！】

![image-20241220021319301](README.assets/image-20241220021319301.png)

方法：

将状态分发到3个集合中：

S_yes - 满足v的状态

S_no - 既满足μ也不满足v的状态

S_? - 满足了μ但未满足μ，但是最终一定会满足μ

如果状态属于S_yes那么x_s=1，如果状态s属于S_no那么x_s=0，如果状态s属于S_?则`x_s=sum(P(s,t) * x_t)`，其中

例子：求下面模型中满足 $P_{>=0.8}\mu U \nu$ 的状态有哪些？

![image-20241220022456342](README.assets/image-20241220022456342.png)



考虑步数的PCTL：记作 $Pr_{~p}$【注意r】

![image-20241220022806665](README.assets/image-20241220022806665.png)

U可以被常数n限制。含义：从当前状态开始n步以内 μUv 需要为真。

![image-20241220023455111](README.assets/image-20241220023455111.png)



![image-20241220024138597](README.assets/image-20241220024138597.png)

$Pr(s, \mu U \nu, t)$：

- 表示从状态s出发，不超过t个时间步到达满足 v的状态的概率。

- 过程中路径上的所有状态必须满足μ。

![image-20241220024424823](README.assets/image-20241220024424823.png)

递归计算路径概率，从t=0往后计算(t=1, t=2, ...)，具体算法见下图。

![image-20241220024631674](README.assets/image-20241220024631674.png)

一个具体的例子：

![image-20241220024754742](README.assets/image-20241220024754742.png)

一个协议的例子：

![image-20241220024826821](README.assets/image-20241220024826821.png)



## Верификация системы реального времени







---

# 题型总结

## 🐟Hoare逻辑(弗洛伊德法)

### 判断程序的正确性(wp, sp)

Вар1, 1

Вар7, 2



### 使用 wp 判断程序的正确性





### 使用 sp 判断程序的正确性





### (2.1) 求抛物线变换后的图像

![image-20241220124120218](README.assets/image-20241220124120218.png)





## 🐟Крипке

### 给定 Крипке + CTL 公式，判定在哪些状态下公式能满足？（必考）

递归标记算法

Вар1, 1

![image-20241218160353237](README.assets/image-20241218160353237.png)





### Крипке + LTL + автомат Бюхи

将公式转化为Buchi自动机，然后验证路径是否接受

Вар2, 2

解法：（L6,S37）

![image-20241218095538122](README.assets/image-20241218095538122.png)





## 🐟LTL

### 🚩用LTL公式表达系统属性(Спецификации  требований на LTL)

考试题：

Вар1,2；

![image-20241218160335652](README.assets/image-20241218160335652.png)

#### 解题方法1：熟练掌握 G, F, X, U 的语义

![image-20241218160625129](README.assets/image-20241218160625129.png)

![image-20241218160800828](README.assets/image-20241218160800828.png)

![image-20241218160956321](README.assets/image-20241218160956321.png)



p68

![image-20241218161057438](README.assets/image-20241218161057438.png)

![image-20241218161204780](README.assets/image-20241218161204780.png)

![image-20241218161229391](README.assets/image-20241218161229391.png)



![image-20241218161547598](README.assets/image-20241218161547598.png)



#### 解题方法2：找出PPT中所有Примеры спецификации  требований на LTL

- PPT《Модуль 10. Применение темпоральных логик для выражения свойств》 - s12






### 🚩证明LTL公式的等价性 // 构造反例 证明两个LTL之间的不同

Вар1,3；

![image-20241218161319571](README.assets/image-20241218161319571.png)

（不确定）解题方法1：分别对两个ltl构造BA，如果BA相等则说明两个ltl等价；如果不等则找出一条路径作为反例证明两个公式不等价。



（不确定）解题方法2：熟悉LTL之间的等式转换？

<img src="README.assets/image-20241218161429005.png" alt="image-20241218161429005" style="zoom:80%;" />

<img src="README.assets/image-20241218161446234.png" alt="image-20241218161446234" style="zoom:80%;" />

<img src="README.assets/image-20241218161458041.png" alt="image-20241218161458041" style="zoom:80%;" />

<img src="README.assets/image-20241218161506034.png" alt="image-20241218161506034" style="zoom: 80%;" />








### 🚩证明或证伪公式

Вар7,4；Вар4,4；





### 🚩构造满足LTL公式的计算【？】

[Вариант 2,3], [Вариант 3,4], 

> Для каждой из формул LTL постройте несколько вычислений, удовлетворяющих ей
>
> ![image-20241218162604578](README.assets/image-20241218162604578.png)





## 🐟Автомат Бюхи

### 根据LTL公式构建Buchi自动机











---

# 补充资料

## 经典命题逻辑

我们通过如下规则定义这种真值指派A在什么时候满足特定公式：

- A满足命题变量P [当且仅当](https://zh.wikipedia.org/wiki/%E5%BD%93%E4%B8%94%E4%BB%85%E5%BD%93)A(P) = **真**
- A满足 ¬φ当且仅当A不满足φ
- A满足(φ ∧ ψ)当且仅当A满足φ与ψ二者
- A满足(φ ∨ ψ)当且仅当A满足φ和ψ中至少一个
- A满足(φ → ψ)当且仅当并非A满足φ但不满足ψ的情况
- A满足(φ ↔ ψ)当且仅当A满足φ与ψ二者，或则不满足它们中的任何一个


### 逻辑等价

> https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7

![Pasted image 20241214123636](README.assets/Pasted image 20241216184434.png)

> 包含蕴含的逻辑等价、包含双蕴含的逻辑等价【重要！】


![Pasted image 20241214123636](README.assets/Pasted image 20241216184523.png)





## 符号模型检测

什么是 Symbolic Model Checking with BDDs？

- 定义：是一种验证有限状态系统的方法。
- **目标：** 验证给定的时序逻辑公式（如 CTL 或 LTL）是否在系统模型中成立。
- 方法核心：
  - 系统的状态和状态转移关系用布尔公式表示，而不是显式枚举所有状态。
  - 使用特征函数（Characteristic Function）来表示状态集合。例如，集合 S 被表示为布尔公式 S(v)，其中 v 是状态变量。
- 主要步骤：
  - 建模：使用 Kripke 结构定义系统，状态和转移关系通过布尔函数编码。
  - 验证：将目标性质（如 CTL 或 LTL 公式）转化为布尔公式，结合固定点算法验证系统模型。



什么是 Fixpoint Algorithms？

- 固定点（Fixpoint）：函数 τ 的固定点是满足 τ(X)=X 的集合X。
- 作用：
  - 固定点算法用于递归定义的集合运算，广泛应用于 CTL 模型检查中。
  - 固定点分为：
    - **最小固定点（Least Fixpoint, LFP）：** 通过递增迭代求得。
    - **最大固定点（Greatest Fixpoint, GFP）：** 通过递减迭代求得。

- 主要性质
  - 单调性：如果 τ 是单调的（X⊆Y  ⟹  τ(X)⊆τ(Y)，则固定点一定存在。
  - 连续性：如果 τ 是连续的，可以通过递归计算近似固定点。



如何用 BDD 对 Kripke 结构进行编码？【？存疑】



---





